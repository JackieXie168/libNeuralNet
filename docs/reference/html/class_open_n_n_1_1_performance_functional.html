<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNN: OpenNN::PerformanceFunctional Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opennn_icon_512x512.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNN
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Open Neural Networks Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>OpenNN</b></li><li class="navelem"><a class="el" href="class_open_n_n_1_1_performance_functional.html">PerformanceFunctional</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_open_n_n_1_1_performance_functional-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenNN::PerformanceFunctional Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="performance__functional_8h_source.html">performance_functional.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_first_orderperformance.html">FirstOrderperformance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_second_orderperformance.html">SecondOrderperformance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_zero_orderperformance.html">ZeroOrderperformance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac700d3aab8c7b2b7f20a56d4addbb8c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac700d3aab8c7b2b7f20a56d4addbb8c7">ObjectiveType</a> { <br/>
&#160;&#160;<b>NO_OBJECTIVE</b>, 
<b>SUM_SQUARED_ERROR_OBJECTIVE</b>, 
<b>MEAN_SQUARED_ERROR_OBJECTIVE</b>, 
<b>ROOT_MEAN_SQUARED_ERROR_OBJECTIVE</b>, 
<br/>
&#160;&#160;<b>NORMALIZED_SQUARED_ERROR_OBJECTIVE</b>, 
<b>MINKOWSKI_ERROR_OBJECTIVE</b>, 
<b>CROSS_ENTROPY_ERROR_OBJECTIVE</b>, 
<b>OUTPUTS_INTEGRALS_OBJECTIVE</b>, 
<br/>
&#160;&#160;<b>SOLUTIONS_ERROR_OBJECTIVE</b>, 
<b>FINAL_SOLUTIONS_ERROR_OBJECTIVE</b>, 
<b>INDEPENDENT_PARAMETERS_ERROR_OBJECTIVE</b>, 
<b>INVERSE_SUM_SQUARED_ERROR_OBJECTIVE</b>, 
<br/>
&#160;&#160;<b>USER_OBJECTIVE</b>
<br/>
 }</td></tr>
<tr class="separator:ac700d3aab8c7b2b7f20a56d4addbb8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4e9613ff3dd4fc43884b1249b66893"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8f4e9613ff3dd4fc43884b1249b66893">RegularizationType</a> { <b>NO_REGULARIZATION</b>, 
<b>NEURAL_PARAMETERS_NORM_REGULARIZATION</b>, 
<b>OUTPUTS_INTEGRALS_REGULARIZATION</b>, 
<b>USER_REGULARIZATION</b>
 }</td></tr>
<tr class="separator:a8f4e9613ff3dd4fc43884b1249b66893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb05a66b3525ab1a89a5472551447fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a3cb05a66b3525ab1a89a5472551447fe">ConstraintsType</a> { <br/>
&#160;&#160;<b>NO_CONSTRAINTS</b>, 
<b>OUTPUTS_INTEGRALS_CONSTRAINTS</b>, 
<b>SOLUTIONS_ERROR_CONSTRAINTS</b>, 
<b>FINAL_SOLUTIONS_ERROR_CONSTRAINTS</b>, 
<br/>
&#160;&#160;<b>INDEPENDENT_PARAMETERS_ERROR_CONSTRAINTS</b>, 
<b>USER_CONSTRAINTS</b>
<br/>
 }</td></tr>
<tr class="separator:a3cb05a66b3525ab1a89a5472551447fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae934085cb524d26b874ea25f56a2c364"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae934085cb524d26b874ea25f56a2c364">PerformanceFunctional</a> (void)</td></tr>
<tr class="separator:ae934085cb524d26b874ea25f56a2c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5a294212396d75c1bc4446dc6185f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#afe5a294212396d75c1bc4446dc6185f8">PerformanceFunctional</a> (<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *)</td></tr>
<tr class="separator:afe5a294212396d75c1bc4446dc6185f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180470a88d21c1c03260797605738668"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a180470a88d21c1c03260797605738668">PerformanceFunctional</a> (<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *)</td></tr>
<tr class="separator:a180470a88d21c1c03260797605738668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c181e4c5fc96d9f4eeaf29c332d2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4f5c181e4c5fc96d9f4eeaf29c332d2a">PerformanceFunctional</a> (<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *, <a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *)</td></tr>
<tr class="separator:a4f5c181e4c5fc96d9f4eeaf29c332d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae778b47af08c04854df45c0c51a8b989"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae778b47af08c04854df45c0c51a8b989">PerformanceFunctional</a> (<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *, <a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *)</td></tr>
<tr class="separator:ae778b47af08c04854df45c0c51a8b989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef875d39dc1d695e579cabaebfd80840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aef875d39dc1d695e579cabaebfd80840">PerformanceFunctional</a> (<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *, <a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *, <a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *)</td></tr>
<tr class="separator:aef875d39dc1d695e579cabaebfd80840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b1b6785b2d04dedc96c2d831f3c6ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a51b1b6785b2d04dedc96c2d831f3c6ea">PerformanceFunctional</a> (const std::string &amp;)</td></tr>
<tr class="separator:a51b1b6785b2d04dedc96c2d831f3c6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06d3ac07810692f7c962f5bb9604c73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aa06d3ac07810692f7c962f5bb9604c73">PerformanceFunctional</a> (const tinyxml2::XMLDocument &amp;)</td></tr>
<tr class="separator:aa06d3ac07810692f7c962f5bb9604c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240555820e883f37ee9344d0a09052b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a240555820e883f37ee9344d0a09052b0">PerformanceFunctional</a> (const <a class="el" href="class_open_n_n_1_1_performance_functional.html">PerformanceFunctional</a> &amp;)</td></tr>
<tr class="separator:a240555820e883f37ee9344d0a09052b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4843ba1fe81a786de21e395c3736a320"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4843ba1fe81a786de21e395c3736a320">~PerformanceFunctional</a> (void)</td></tr>
<tr class="separator:a4843ba1fe81a786de21e395c3736a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897c29c61170d7bf82f3f75a9cafadc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a897c29c61170d7bf82f3f75a9cafadc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a897c29c61170d7bf82f3f75a9cafadc7">check_neural_network</a> (void) const </td></tr>
<tr class="separator:a897c29c61170d7bf82f3f75a9cafadc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08e75fe5f7ed2dc57d250e15a22d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0a08e75fe5f7ed2dc57d250e15a22d50">check_performance_terms</a> (void) const </td></tr>
<tr class="separator:a0a08e75fe5f7ed2dc57d250e15a22d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d992ddddb4281f1da8c078b2db2610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4d992ddddb4281f1da8c078b2db2610"></a>
<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ad4d992ddddb4281f1da8c078b2db2610">get_neural_network_pointer</a> (void) const </td></tr>
<tr class="separator:ad4d992ddddb4281f1da8c078b2db2610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e096bde86e05127500fde2ac543ffd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e096bde86e05127500fde2ac543ffd8"></a>
<a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4e096bde86e05127500fde2ac543ffd8">get_mathematical_model_pointer</a> (void) const </td></tr>
<tr class="separator:a4e096bde86e05127500fde2ac543ffd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bd5a8bda0080c384704e5f540e2af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a305bd5a8bda0080c384704e5f540e2af"></a>
<a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a305bd5a8bda0080c384704e5f540e2af">get_data_set_pointer</a> (void) const </td></tr>
<tr class="separator:a305bd5a8bda0080c384704e5f540e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae60cd9ba71d1757d1d935eda0355755"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aae60cd9ba71d1757d1d935eda0355755">has_neural_network</a> (void) const </td></tr>
<tr class="separator:aae60cd9ba71d1757d1d935eda0355755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce8b800db9415f1b25a9fcb24d9e27d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8ce8b800db9415f1b25a9fcb24d9e27d">has_mathematical_model</a> (void) const </td></tr>
<tr class="separator:a8ce8b800db9415f1b25a9fcb24d9e27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937dfe9f2fd6e94ddd647765e1b013fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a937dfe9f2fd6e94ddd647765e1b013fa">has_data_set</a> (void) const </td></tr>
<tr class="separator:a937dfe9f2fd6e94ddd647765e1b013fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4b9d73eea3a9d01a13ed1142bad7ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a9e4b9d73eea3a9d01a13ed1142bad7ff">has_generalization</a> (void) const </td></tr>
<tr class="separator:a9e4b9d73eea3a9d01a13ed1142bad7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae77ed9e661528ee8c0dadae2b57643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_sum_squared_error.html">SumSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#adae77ed9e661528ee8c0dadae2b57643">get_sum_squared_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:adae77ed9e661528ee8c0dadae2b57643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107e2da8e3f36b905927fb3dff8b1943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_mean_squared_error.html">MeanSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a107e2da8e3f36b905927fb3dff8b1943">get_mean_squared_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a107e2da8e3f36b905927fb3dff8b1943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f7f92cdb63928b951f59746ecf5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_root_mean_squared_error.html">RootMeanSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac29f7f92cdb63928b951f59746ecf5d5">get_root_mean_squared_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:ac29f7f92cdb63928b951f59746ecf5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7aca3980e4f52a7f59fd7f557b92417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_normalized_squared_error.html">NormalizedSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac7aca3980e4f52a7f59fd7f557b92417">get_normalized_squared_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:ac7aca3980e4f52a7f59fd7f557b92417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d07de4e0ce3441470ec4f3a4e1e5bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_minkowski_error.html">MinkowskiError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8d07de4e0ce3441470ec4f3a4e1e5bdb">get_Minkowski_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a8d07de4e0ce3441470ec4f3a4e1e5bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584c8f2b3724e77f8987b30d964a77c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_cross_entropy_error.html">CrossEntropyError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0584c8f2b3724e77f8987b30d964a77c">get_cross_entropy_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a0584c8f2b3724e77f8987b30d964a77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f59ab334da717b8f737cb962e6d3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ad9f59ab334da717b8f737cb962e6d3fe">get_outputs_integrals_objective_pointer</a> (void) const </td></tr>
<tr class="separator:ad9f59ab334da717b8f737cb962e6d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d342b93459bc6a4602025185ac9d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a88d342b93459bc6a4602025185ac9d19">get_solutions_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a88d342b93459bc6a4602025185ac9d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0985e9e2448d756c3a09d04e26796910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0985e9e2448d756c3a09d04e26796910">get_final_solutions_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a0985e9e2448d756c3a09d04e26796910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67383e2ac2e82eb75407256f5def9323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a67383e2ac2e82eb75407256f5def9323">get_independent_parameters_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a67383e2ac2e82eb75407256f5def9323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e004f29e554d83a4a200891cdd777c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_inverse_sum_squared_error.html">InverseSumSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a3e004f29e554d83a4a200891cdd777c0">get_inverse_sum_squared_error_objective_pointer</a> (void) const </td></tr>
<tr class="separator:a3e004f29e554d83a4a200891cdd777c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f990bd8bfa1bb92b83a2795a4b9c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac7f990bd8bfa1bb92b83a2795a4b9c1b">get_user_objective_pointer</a> (void) const </td></tr>
<tr class="separator:ac7f990bd8bfa1bb92b83a2795a4b9c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0461757be2d42abc68462e154b97cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_neural_parameters_norm.html">NeuralParametersNorm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ab0461757be2d42abc68462e154b97cf0">get_neural_parameters_norm_regularization_pointer</a> (void) const </td></tr>
<tr class="separator:ab0461757be2d42abc68462e154b97cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2282fcca1a9d9bb5b0d15238099cb271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a2282fcca1a9d9bb5b0d15238099cb271">get_outputs_integrals_regularization_pointer</a> (void) const </td></tr>
<tr class="separator:a2282fcca1a9d9bb5b0d15238099cb271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003759a796ebddd2bcdbe956fdb33964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a003759a796ebddd2bcdbe956fdb33964">get_user_regularization_pointer</a> (void) const </td></tr>
<tr class="separator:a003759a796ebddd2bcdbe956fdb33964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5014c5096cc16c39bd94fd4c7086842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae5014c5096cc16c39bd94fd4c7086842">get_outputs_integrals_constraints_pointer</a> (void) const </td></tr>
<tr class="separator:ae5014c5096cc16c39bd94fd4c7086842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac020e8e2360fbe84cb5d056bf8cacfd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac020e8e2360fbe84cb5d056bf8cacfd0">get_solutions_error_constraints_pointer</a> (void) const </td></tr>
<tr class="separator:ac020e8e2360fbe84cb5d056bf8cacfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f1f9428c35518bf845baaa8ce21785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a80f1f9428c35518bf845baaa8ce21785">get_final_solutions_error_constraints_pointer</a> (void) const </td></tr>
<tr class="separator:a80f1f9428c35518bf845baaa8ce21785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ffd8988f86b990798cdb43d43ff0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae2ffd8988f86b990798cdb43d43ff0f5">get_independent_parameters_error_constraints_pointer</a> (void) const </td></tr>
<tr class="separator:ae2ffd8988f86b990798cdb43d43ff0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0c5fd6b7f5be388413b228e58a4812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1a0c5fd6b7f5be388413b228e58a4812">get_user_constraints_pointer</a> (void) const </td></tr>
<tr class="separator:a1a0c5fd6b7f5be388413b228e58a4812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3287eeac30e4a70cbf2d42a8a56b1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d3287eeac30e4a70cbf2d42a8a56b1c"></a>
const <a class="el" href="class_open_n_n_1_1_performance_functional.html#ac700d3aab8c7b2b7f20a56d4addbb8c7">ObjectiveType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a3d3287eeac30e4a70cbf2d42a8a56b1c">get_objective_type</a> (void) const </td></tr>
<tr class="separator:a3d3287eeac30e4a70cbf2d42a8a56b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc727258bd6a28feac5b6a96a78a099"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdc727258bd6a28feac5b6a96a78a099"></a>
const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a8f4e9613ff3dd4fc43884b1249b66893">RegularizationType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#acdc727258bd6a28feac5b6a96a78a099">get_regularization_type</a> (void) const </td></tr>
<tr class="separator:acdc727258bd6a28feac5b6a96a78a099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b2630f0f321f4c9347371d21715c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a763b2630f0f321f4c9347371d21715c5"></a>
const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a3cb05a66b3525ab1a89a5472551447fe">ConstraintsType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a763b2630f0f321f4c9347371d21715c5">get_constraints_type</a> (void) const </td></tr>
<tr class="separator:a763b2630f0f321f4c9347371d21715c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617dea8a90d2e077a4ff959be7da6377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a617dea8a90d2e077a4ff959be7da6377"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a617dea8a90d2e077a4ff959be7da6377">write_objective_type</a> (void) const </td></tr>
<tr class="separator:a617dea8a90d2e077a4ff959be7da6377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1942f71dcc8fb2dda9840e1838da613b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1942f71dcc8fb2dda9840e1838da613b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1942f71dcc8fb2dda9840e1838da613b">write_regularization_type</a> (void) const </td></tr>
<tr class="separator:a1942f71dcc8fb2dda9840e1838da613b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb31af4aa5a29e8142d95315dad540b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb31af4aa5a29e8142d95315dad540b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#abcb31af4aa5a29e8142d95315dad540b">write_constraints_type</a> (void) const </td></tr>
<tr class="separator:abcb31af4aa5a29e8142d95315dad540b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623a1eb6f77c7f5594ce5ddd0b043ca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a623a1eb6f77c7f5594ce5ddd0b043ca6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a623a1eb6f77c7f5594ce5ddd0b043ca6">write_objective_type_text</a> (void) const </td></tr>
<tr class="separator:a623a1eb6f77c7f5594ce5ddd0b043ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722574508d935e2e952f59dc9bfcc2b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a722574508d935e2e952f59dc9bfcc2b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a722574508d935e2e952f59dc9bfcc2b1">write_regularization_type_text</a> (void) const </td></tr>
<tr class="separator:a722574508d935e2e952f59dc9bfcc2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aba55bd19acfcf6867ce53b958d88b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aba55bd19acfcf6867ce53b958d88b0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a2aba55bd19acfcf6867ce53b958d88b0">write_constraints_type_text</a> (void) const </td></tr>
<tr class="separator:a2aba55bd19acfcf6867ce53b958d88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b5dd6bb62ad5cfee2c611325e9c0e"><td class="memItemLeft" align="right" valign="top">const bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae66b5dd6bb62ad5cfee2c611325e9c0e">get_display</a> (void) const </td></tr>
<tr class="separator:ae66b5dd6bb62ad5cfee2c611325e9c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbacd95bd097d39e101eca9658f001c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a9cbacd95bd097d39e101eca9658f001c">set_neural_network_pointer</a> (<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *)</td></tr>
<tr class="separator:a9cbacd95bd097d39e101eca9658f001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5611693b353ccec3cce2309760c96433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a5611693b353ccec3cce2309760c96433">set_mathematical_model_pointer</a> (<a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *)</td></tr>
<tr class="separator:a5611693b353ccec3cce2309760c96433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1202c74530320bc44bb538dc2fd1a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ad1202c74530320bc44bb538dc2fd1a79">set_data_set_pointer</a> (<a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *)</td></tr>
<tr class="separator:ad1202c74530320bc44bb538dc2fd1a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab857bd0c85f358bdb2a7b57b56f33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8ab857bd0c85f358bdb2a7b57b56f33e">set_user_objective_pointer</a> (<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *)</td></tr>
<tr class="separator:a8ab857bd0c85f358bdb2a7b57b56f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0eae3cb0aa02d3324c5004099ee1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a6d0eae3cb0aa02d3324c5004099ee1a4">set_user_regularization_pointer</a> (<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *)</td></tr>
<tr class="separator:a6d0eae3cb0aa02d3324c5004099ee1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d74d21f2b0357ce42c2ddd97fc39563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a2d74d21f2b0357ce42c2ddd97fc39563">set_user_constraints_pointer</a> (<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *)</td></tr>
<tr class="separator:a2d74d21f2b0357ce42c2ddd97fc39563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f41e4c363cf90feb05b9c739d9758d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f41e4c363cf90feb05b9c739d9758d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a5f41e4c363cf90feb05b9c739d9758d1">set_default</a> (void)</td></tr>
<tr class="separator:a5f41e4c363cf90feb05b9c739d9758d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16756324648a453631b730af6cfb6791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a16756324648a453631b730af6cfb6791">set_objective_type</a> (const <a class="el" href="class_open_n_n_1_1_performance_functional.html#ac700d3aab8c7b2b7f20a56d4addbb8c7">ObjectiveType</a> &amp;)</td></tr>
<tr class="separator:a16756324648a453631b730af6cfb6791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4220578a93f57a260e19d97ffe2271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aeb4220578a93f57a260e19d97ffe2271">set_regularization_type</a> (const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a8f4e9613ff3dd4fc43884b1249b66893">RegularizationType</a> &amp;)</td></tr>
<tr class="separator:aeb4220578a93f57a260e19d97ffe2271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a93d173f3138f0003ebbdec0abc9de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a29a93d173f3138f0003ebbdec0abc9de">set_constraints_type</a> (const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a3cb05a66b3525ab1a89a5472551447fe">ConstraintsType</a> &amp;)</td></tr>
<tr class="separator:a29a93d173f3138f0003ebbdec0abc9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4c933a0fe5e962bf1a96551560eea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a6e4c933a0fe5e962bf1a96551560eea7">set_objective_type</a> (const std::string &amp;)</td></tr>
<tr class="separator:a6e4c933a0fe5e962bf1a96551560eea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a71b62ea2ab5acb8d3dbc52a755b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ab5a71b62ea2ab5acb8d3dbc52a755b33">set_regularization_type</a> (const std::string &amp;)</td></tr>
<tr class="separator:ab5a71b62ea2ab5acb8d3dbc52a755b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea355d04dc624b97ef7573590204e000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aea355d04dc624b97ef7573590204e000">set_constraints_type</a> (const std::string &amp;)</td></tr>
<tr class="separator:aea355d04dc624b97ef7573590204e000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298db532ce7f97a4efaa6fd423277a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a298db532ce7f97a4efaa6fd423277a8e">destruct_objective</a> (void)</td></tr>
<tr class="separator:a298db532ce7f97a4efaa6fd423277a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca15c610b958c07de111c850d8b8f20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a3ca15c610b958c07de111c850d8b8f20">destruct_regularization</a> (void)</td></tr>
<tr class="separator:a3ca15c610b958c07de111c850d8b8f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade324d9351e942dfd121ac99ec547ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ade324d9351e942dfd121ac99ec547ff4">destruct_constraints</a> (void)</td></tr>
<tr class="separator:ade324d9351e942dfd121ac99ec547ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1acf3f26152c49d8e9500a6bfbdc48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1acf3f26152c49d8e9500a6bfbdc48c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#af1acf3f26152c49d8e9500a6bfbdc48c">destruct_all_terms</a> (void)</td></tr>
<tr class="separator:af1acf3f26152c49d8e9500a6bfbdc48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8292e63c87e2ab2f80991eafec1022a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8292e63c87e2ab2f80991eafec1022a0">set_display</a> (const bool &amp;)</td></tr>
<tr class="separator:a8292e63c87e2ab2f80991eafec1022a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb79570d8df54955eebfcf3672f3806"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0bb79570d8df54955eebfcf3672f3806">calculate_objective</a> (void) const </td></tr>
<tr class="separator:a0bb79570d8df54955eebfcf3672f3806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17230372c9f0ee39c21e7c77662eb678"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a17230372c9f0ee39c21e7c77662eb678">calculate_regularization</a> (void) const </td></tr>
<tr class="separator:a17230372c9f0ee39c21e7c77662eb678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d4b72fc9b02535a29b8283a53dc9b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a24d4b72fc9b02535a29b8283a53dc9b7">calculate_constraints</a> (void) const </td></tr>
<tr class="separator:a24d4b72fc9b02535a29b8283a53dc9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb58a9c980b57b144511b53e5539eff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1cb58a9c980b57b144511b53e5539eff">calculate_objective</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a1cb58a9c980b57b144511b53e5539eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8f4b0c704b73b811eb279c0585a078"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aff8f4b0c704b73b811eb279c0585a078">calculate_regularization</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:aff8f4b0c704b73b811eb279c0585a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661fa98f3f3a3419150d864c80542844"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a661fa98f3f3a3419150d864c80542844">calculate_constraints</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a661fa98f3f3a3419150d864c80542844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d1c51ad572859d9fa783bbda2e945f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a38d1c51ad572859d9fa783bbda2e945f">calculate_objective_terms</a> (void) const </td></tr>
<tr class="separator:a38d1c51ad572859d9fa783bbda2e945f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e83b2738d9dea8f1998f21df6b962f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0e83b2738d9dea8f1998f21df6b962f5">calculate_regularization_terms</a> (void) const </td></tr>
<tr class="separator:a0e83b2738d9dea8f1998f21df6b962f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42efac3b8b04a72d6acfd83b558c8145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a42efac3b8b04a72d6acfd83b558c8145">calculate_constraints_terms</a> (void) const </td></tr>
<tr class="separator:a42efac3b8b04a72d6acfd83b558c8145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aea45462340f1ca1095467a9f81a717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4aea45462340f1ca1095467a9f81a717">calculate_objective_terms_Jacobian</a> (void) const </td></tr>
<tr class="separator:a4aea45462340f1ca1095467a9f81a717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c1362c60440cf388dd95a997622afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a63c1362c60440cf388dd95a997622afa">calculate_regularization_terms_Jacobian</a> (void) const </td></tr>
<tr class="separator:a63c1362c60440cf388dd95a997622afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e35818ffbd6ea8f76cd85bb40129820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1e35818ffbd6ea8f76cd85bb40129820">calculate_constraints_terms_Jacobian</a> (void) const </td></tr>
<tr class="separator:a1e35818ffbd6ea8f76cd85bb40129820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11435c2d4956df56c592fc7631c908f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a11435c2d4956df56c592fc7631c908f3">calculate_objective_gradient</a> (void) const </td></tr>
<tr class="separator:a11435c2d4956df56c592fc7631c908f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446879d58a1c823c60e46df1f8f20dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a446879d58a1c823c60e46df1f8f20dc5">calculate_regularization_gradient</a> (void) const </td></tr>
<tr class="separator:a446879d58a1c823c60e46df1f8f20dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96a36f45aa32fa368a2df71447bef2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac96a36f45aa32fa368a2df71447bef2f">calculate_constraints_gradient</a> (void) const </td></tr>
<tr class="separator:ac96a36f45aa32fa368a2df71447bef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2a8427b252378e49a8cbb5658472dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a5c2a8427b252378e49a8cbb5658472dd">calculate_objective_gradient</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a5c2a8427b252378e49a8cbb5658472dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16d6e10a5ebdbad70c1cc342724c20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ab16d6e10a5ebdbad70c1cc342724c20a">calculate_regularization_gradient</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:ab16d6e10a5ebdbad70c1cc342724c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc2eba35c0dab870ef4d66e1a6b71cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#adfc2eba35c0dab870ef4d66e1a6b71cc">calculate_constraints_gradient</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:adfc2eba35c0dab870ef4d66e1a6b71cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf49abba36aafaeace9771e69d4a1fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aaf49abba36aafaeace9771e69d4a1fe1">calculate_objective_Hessian</a> (void) const </td></tr>
<tr class="separator:aaf49abba36aafaeace9771e69d4a1fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59ab3a1efd3c691cd8b97a071065081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae59ab3a1efd3c691cd8b97a071065081">calculate_regularization_Hessian</a> (void) const </td></tr>
<tr class="separator:ae59ab3a1efd3c691cd8b97a071065081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2499cd488e3c92bba49e9dacb66406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a2b2499cd488e3c92bba49e9dacb66406">calculate_constraints_Hessian</a> (void) const </td></tr>
<tr class="separator:a2b2499cd488e3c92bba49e9dacb66406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b848c89cc10fc067e4683e6d4e3b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aa3b848c89cc10fc067e4683e6d4e3b9a">calculate_objective_Hessian</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:aa3b848c89cc10fc067e4683e6d4e3b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c90e518afd511e99b128c9d45cf4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a21c90e518afd511e99b128c9d45cf4b1">calculate_regularization_Hessian</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a21c90e518afd511e99b128c9d45cf4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e4895dfd91269bc89b5cbb86cf3fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a16e4895dfd91269bc89b5cbb86cf3fb8">calculate_constraints_Hessian</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a16e4895dfd91269bc89b5cbb86cf3fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5e946a6c0271bd8995fb463bf83b83"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4c5e946a6c0271bd8995fb463bf83b83">calculate_performance</a> (void) const </td></tr>
<tr class="separator:a4c5e946a6c0271bd8995fb463bf83b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae737dd930d87aeba1e160fd4b557c672"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae737dd930d87aeba1e160fd4b557c672"></a>
<a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae737dd930d87aeba1e160fd4b557c672">calculate_gradient</a> (void) const </td></tr>
<tr class="separator:ae737dd930d87aeba1e160fd4b557c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7fa47593e4c7c23092d2c25469bec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ace7fa47593e4c7c23092d2c25469bec9">calculate_Hessian</a> (void) const </td></tr>
<tr class="separator:ace7fa47593e4c7c23092d2c25469bec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5896c72e544457f953af44dd760c90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aae5896c72e544457f953af44dd760c90">calculate_performance</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:aae5896c72e544457f953af44dd760c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc08cefd4ebfbe2202338cd9204b5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#abdc08cefd4ebfbe2202338cd9204b5db">calculate_gradient</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:abdc08cefd4ebfbe2202338cd9204b5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98113c902a89ab481e6f5cd562e77556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a98113c902a89ab481e6f5cd562e77556">calculate_Hessian</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a98113c902a89ab481e6f5cd562e77556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06870da51e497f42806dc3a83a8b27b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a06870da51e497f42806dc3a83a8b27b6">calculate_inverse_Hessian</a> (void) const </td></tr>
<tr class="separator:a06870da51e497f42806dc3a83a8b27b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e518203cce32fb68e5395242253e19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a18e518203cce32fb68e5395242253e19">calculate_vector_dot_Hessian</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a18e518203cce32fb68e5395242253e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3260d73f437da8cae5d1937b388452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#abd3260d73f437da8cae5d1937b388452">calculate_terms</a> (void) const </td></tr>
<tr class="separator:abd3260d73f437da8cae5d1937b388452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32af53af6abcb22c5978de16159955ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a32af53af6abcb22c5978de16159955ce">calculate_terms_Jacobian</a> (void) const </td></tr>
<tr class="separator:a32af53af6abcb22c5978de16159955ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a53924a4cd1ca8591fcec009b995c17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a53924a4cd1ca8591fcec009b995c17"></a>
virtual <a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_zero_orderperformance.html">ZeroOrderperformance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1a53924a4cd1ca8591fcec009b995c17">calculate_zero_order_performance</a> (void) const </td></tr>
<tr class="separator:a1a53924a4cd1ca8591fcec009b995c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf462cac723cabb58d5a0fb2473630f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf462cac723cabb58d5a0fb2473630f"></a>
virtual <a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_first_orderperformance.html">FirstOrderperformance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#adbf462cac723cabb58d5a0fb2473630f">calculate_first_order_performance</a> (void) const </td></tr>
<tr class="separator:adbf462cac723cabb58d5a0fb2473630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd59f94757dc036986a704271695c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fbd59f94757dc036986a704271695c0"></a>
virtual <a class="el" href="struct_open_n_n_1_1_performance_functional_1_1_second_orderperformance.html">SecondOrderperformance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4fbd59f94757dc036986a704271695c0">calculate_second_order_performance</a> (void) const </td></tr>
<tr class="separator:a4fbd59f94757dc036986a704271695c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027971fa75187eaf42cad7984e232559"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a027971fa75187eaf42cad7984e232559"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a027971fa75187eaf42cad7984e232559">calculate_generalization_objective</a> (void) const </td></tr>
<tr class="separator:a027971fa75187eaf42cad7984e232559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1efeeb2136ef5ea055823221b673bc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1efeeb2136ef5ea055823221b673bc0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac1efeeb2136ef5ea055823221b673bc0">calculate_generalization_regularization</a> (void) const </td></tr>
<tr class="separator:ac1efeeb2136ef5ea055823221b673bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa974b67879d44fb14e79c36c267f348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa974b67879d44fb14e79c36c267f348"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aaa974b67879d44fb14e79c36c267f348">calculate_generalization_constraints</a> (void) const </td></tr>
<tr class="separator:aaa974b67879d44fb14e79c36c267f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0176ba03640588382f2acc57e2d04cf8"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0176ba03640588382f2acc57e2d04cf8">calculate_generalization_performance</a> (void) const </td></tr>
<tr class="separator:a0176ba03640588382f2acc57e2d04cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157523e586f178deaa674a3527c74068"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a157523e586f178deaa674a3527c74068">calculate_zero_order_Taylor_approximation</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a157523e586f178deaa674a3527c74068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cf6b0b32806342b973db17d1e552e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a39cf6b0b32806342b973db17d1e552e4">calculate_first_order_Taylor_approximation</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a39cf6b0b32806342b973db17d1e552e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7385b1b6a129f8357758c4757bbec08b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a7385b1b6a129f8357758c4757bbec08b">calculate_second_order_Taylor_approximation</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;) const </td></tr>
<tr class="separator:a7385b1b6a129f8357758c4757bbec08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002f687eed18332d085f384624026702"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a002f687eed18332d085f384624026702">calculate_performance</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;, const double &amp;) const </td></tr>
<tr class="separator:a002f687eed18332d085f384624026702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a948b979f2c1ba7eabf23a7002fd97"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a57a948b979f2c1ba7eabf23a7002fd97">calculate_performance_derivative</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;, const double &amp;) const </td></tr>
<tr class="separator:a57a948b979f2c1ba7eabf23a7002fd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1459980ed63ecfe0b419146031a9c90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae1459980ed63ecfe0b419146031a9c90">calculate_performance_second_derivative</a> (const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;, const double &amp;) const </td></tr>
<tr class="separator:ae1459980ed63ecfe0b419146031a9c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade7042ad9678036715ae93cee6f346"><td class="memItemLeft" align="right" valign="top">virtual tinyxml2::XMLDocument *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#adade7042ad9678036715ae93cee6f346">to_XML</a> (void) const </td></tr>
<tr class="separator:adade7042ad9678036715ae93cee6f346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f57d08b92a89c3c66247c571cee296a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a9f57d08b92a89c3c66247c571cee296a">from_XML</a> (const tinyxml2::XMLDocument &amp;)</td></tr>
<tr class="separator:a9f57d08b92a89c3c66247c571cee296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30f3cfce053d3adae19f10bf71360f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e30f3cfce053d3adae19f10bf71360f"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1e30f3cfce053d3adae19f10bf71360f">to_string</a> (void) const </td></tr>
<tr class="separator:a1e30f3cfce053d3adae19f10bf71360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788547aedb28a2a0df57db278490252"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aa788547aedb28a2a0df57db278490252">save</a> (const std::string &amp;) const </td></tr>
<tr class="separator:aa788547aedb28a2a0df57db278490252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefac6dcec92e89c0160d0569b68bf11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#adefac6dcec92e89c0160d0569b68bf11">load</a> (const std::string &amp;)</td></tr>
<tr class="separator:adefac6dcec92e89c0160d0569b68bf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6c610158bf2e4bcce7b3e7d33fbaf4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a4e6c610158bf2e4bcce7b3e7d33fbaf4">write_information</a> (void)</td></tr>
<tr class="separator:a4e6c610158bf2e4bcce7b3e7d33fbaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745d07d15e4f04d6e19d35a9ca62603a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a745d07d15e4f04d6e19d35a9ca62603a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a745d07d15e4f04d6e19d35a9ca62603a">print</a> (void) const </td></tr>
<tr class="separator:a745d07d15e4f04d6e19d35a9ca62603a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae63affe1cc7e8ba1adf5569d25453479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63affe1cc7e8ba1adf5569d25453479"></a>
<a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ae63affe1cc7e8ba1adf5569d25453479">neural_network_pointer</a></td></tr>
<tr class="separator:ae63affe1cc7e8ba1adf5569d25453479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d273f955df08bf3f72e0f2b670c17e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d273f955df08bf3f72e0f2b670c17e"></a>
<a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ab0d273f955df08bf3f72e0f2b670c17e">data_set_pointer</a></td></tr>
<tr class="separator:ab0d273f955df08bf3f72e0f2b670c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaee579629fc1af3a53ca75012127e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eaee579629fc1af3a53ca75012127e8"></a>
<a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1eaee579629fc1af3a53ca75012127e8">mathematical_model_pointer</a></td></tr>
<tr class="separator:a1eaee579629fc1af3a53ca75012127e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775e3cf5e28733ad5a7f54a6d13f5396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a775e3cf5e28733ad5a7f54a6d13f5396"></a>
<a class="el" href="class_open_n_n_1_1_performance_functional.html#ac700d3aab8c7b2b7f20a56d4addbb8c7">ObjectiveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a775e3cf5e28733ad5a7f54a6d13f5396">objective_type</a></td></tr>
<tr class="separator:a775e3cf5e28733ad5a7f54a6d13f5396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e99c88ca3787f40baf7d8ae83ef6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8e99c88ca3787f40baf7d8ae83ef6b5"></a>
<a class="el" href="class_open_n_n_1_1_performance_functional.html#a8f4e9613ff3dd4fc43884b1249b66893">RegularizationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac8e99c88ca3787f40baf7d8ae83ef6b5">regularization_type</a></td></tr>
<tr class="separator:ac8e99c88ca3787f40baf7d8ae83ef6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61384781d1c1b1791203f030a1df5293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61384781d1c1b1791203f030a1df5293"></a>
<a class="el" href="class_open_n_n_1_1_performance_functional.html#a3cb05a66b3525ab1a89a5472551447fe">ConstraintsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a61384781d1c1b1791203f030a1df5293">constraints_type</a></td></tr>
<tr class="separator:a61384781d1c1b1791203f030a1df5293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fee9a8166968c5bd1e9e5f9e454ed05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fee9a8166968c5bd1e9e5f9e454ed05"></a>
<a class="el" href="class_open_n_n_1_1_sum_squared_error.html">SumSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a6fee9a8166968c5bd1e9e5f9e454ed05">sum_squared_error_objective_pointer</a></td></tr>
<tr class="separator:a6fee9a8166968c5bd1e9e5f9e454ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c448774c8af22e7aefdcac4f1e4e61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c448774c8af22e7aefdcac4f1e4e61"></a>
<a class="el" href="class_open_n_n_1_1_mean_squared_error.html">MeanSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a47c448774c8af22e7aefdcac4f1e4e61">mean_squared_error_objective_pointer</a></td></tr>
<tr class="separator:a47c448774c8af22e7aefdcac4f1e4e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7da61a3494231ba88c45a6d7a20b68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa7da61a3494231ba88c45a6d7a20b68"></a>
<a class="el" href="class_open_n_n_1_1_root_mean_squared_error.html">RootMeanSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aaa7da61a3494231ba88c45a6d7a20b68">root_mean_squared_error_objective_pointer</a></td></tr>
<tr class="separator:aaa7da61a3494231ba88c45a6d7a20b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5b93c5e3e2c5250abf31fd468264e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5e5b93c5e3e2c5250abf31fd468264e"></a>
<a class="el" href="class_open_n_n_1_1_normalized_squared_error.html">NormalizedSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ab5e5b93c5e3e2c5250abf31fd468264e">normalized_squared_error_objective_pointer</a></td></tr>
<tr class="separator:ab5e5b93c5e3e2c5250abf31fd468264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce7a2308aec84e38898f9e54fe3d60d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce7a2308aec84e38898f9e54fe3d60d"></a>
<a class="el" href="class_open_n_n_1_1_minkowski_error.html">MinkowskiError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a1ce7a2308aec84e38898f9e54fe3d60d">Minkowski_error_objective_pointer</a></td></tr>
<tr class="separator:a1ce7a2308aec84e38898f9e54fe3d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b591d0655d4924f85bb3f95351928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac26b591d0655d4924f85bb3f95351928"></a>
<a class="el" href="class_open_n_n_1_1_cross_entropy_error.html">CrossEntropyError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac26b591d0655d4924f85bb3f95351928">cross_entropy_error_objective_pointer</a></td></tr>
<tr class="separator:ac26b591d0655d4924f85bb3f95351928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59d3184095ca6bd0cfd737fb4f5827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed59d3184095ca6bd0cfd737fb4f5827"></a>
<a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aed59d3184095ca6bd0cfd737fb4f5827">outputs_integrals_objective_pointer</a></td></tr>
<tr class="separator:aed59d3184095ca6bd0cfd737fb4f5827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1970df426b8587f7849c3a1c4a6757b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1970df426b8587f7849c3a1c4a6757b"></a>
<a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ad1970df426b8587f7849c3a1c4a6757b">solutions_error_objective_pointer</a></td></tr>
<tr class="separator:ad1970df426b8587f7849c3a1c4a6757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b0d8dbecc3e022a03f00f170c7771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11b0d8dbecc3e022a03f00f170c7771"></a>
<a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ac11b0d8dbecc3e022a03f00f170c7771">final_solutions_error_objective_pointer</a></td></tr>
<tr class="separator:ac11b0d8dbecc3e022a03f00f170c7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43f0be338cad66628304888f20f910a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad43f0be338cad66628304888f20f910a"></a>
<a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#ad43f0be338cad66628304888f20f910a">independent_parameters_error_objective_pointer</a></td></tr>
<tr class="separator:ad43f0be338cad66628304888f20f910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdb76b63929736c519cd193e3e4ad64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafdb76b63929736c519cd193e3e4ad64"></a>
<a class="el" href="class_open_n_n_1_1_inverse_sum_squared_error.html">InverseSumSquaredError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aafdb76b63929736c519cd193e3e4ad64">inverse_sum_squared_error_objective_pointer</a></td></tr>
<tr class="separator:aafdb76b63929736c519cd193e3e4ad64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf01a75d29f982d8b3338bb86170c56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cf01a75d29f982d8b3338bb86170c56"></a>
<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a0cf01a75d29f982d8b3338bb86170c56">user_objective_pointer</a></td></tr>
<tr class="separator:a0cf01a75d29f982d8b3338bb86170c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d41adcb22455249434d4f915b10b8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d41adcb22455249434d4f915b10b8f"></a>
<a class="el" href="class_open_n_n_1_1_neural_parameters_norm.html">NeuralParametersNorm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a15d41adcb22455249434d4f915b10b8f">neural_parameters_norm_regularization_pointer</a></td></tr>
<tr class="separator:a15d41adcb22455249434d4f915b10b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b16f9e394139d7fe22e2d8c5cff2e7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b16f9e394139d7fe22e2d8c5cff2e7d"></a>
<a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a6b16f9e394139d7fe22e2d8c5cff2e7d">outputs_integrals_regularization_pointer</a></td></tr>
<tr class="separator:a6b16f9e394139d7fe22e2d8c5cff2e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9e7d42993bf185be41ff9b66b1142f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e9e7d42993bf185be41ff9b66b1142f"></a>
<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a9e9e7d42993bf185be41ff9b66b1142f">user_regularization_pointer</a></td></tr>
<tr class="separator:a9e9e7d42993bf185be41ff9b66b1142f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96b267aad4af45e910b6f917e790e4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96b267aad4af45e910b6f917e790e4f"></a>
<a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#af96b267aad4af45e910b6f917e790e4f">outputs_integrals_constraints_pointer</a></td></tr>
<tr class="separator:af96b267aad4af45e910b6f917e790e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27aba3d128297267f3079f8fbbf6f9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa27aba3d128297267f3079f8fbbf6f9a"></a>
<a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#aa27aba3d128297267f3079f8fbbf6f9a">solutions_error_constraints_pointer</a></td></tr>
<tr class="separator:aa27aba3d128297267f3079f8fbbf6f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910f60d358a024492d1413a0136bc60d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a910f60d358a024492d1413a0136bc60d"></a>
<a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a910f60d358a024492d1413a0136bc60d">final_solutions_error_constraints_pointer</a></td></tr>
<tr class="separator:a910f60d358a024492d1413a0136bc60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926976963d2224b2c4563f5329dd0a6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a926976963d2224b2c4563f5329dd0a6a"></a>
<a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a926976963d2224b2c4563f5329dd0a6a">independent_parameters_error_constraints_pointer</a></td></tr>
<tr class="separator:a926976963d2224b2c4563f5329dd0a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c89699b3850c9ad04c8ea52d50ec51e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c89699b3850c9ad04c8ea52d50ec51e"></a>
<a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a8c89699b3850c9ad04c8ea52d50ec51e">user_constraints_pointer</a></td></tr>
<tr class="separator:a8c89699b3850c9ad04c8ea52d50ec51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744de1d6e173125dac35a01783c47a26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a744de1d6e173125dac35a01783c47a26"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_n_n_1_1_performance_functional.html#a744de1d6e173125dac35a01783c47a26">display</a></td></tr>
<tr class="separator:a744de1d6e173125dac35a01783c47a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This abstract class represents the concept of performance functional for a neural network. A performance functional is composed of three terms: An performance term, a regularization functional and a constraints functional. Any derived class must implement the calculate_performance(void) method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae934085cb524d26b874ea25f56a2c364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. It creates a performance functional object with all pointers initialized to NULL. It also initializes all the rest of class members to their default values. </p>

</div>
</div>
<a class="anchor" id="afe5a294212396d75c1bc4446dc6185f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td>
          <td class="paramname"><em>new_user_objective_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Objective term constructor. It creates a performance functional object with a given objective functional. The rest of pointers are initialized to NULL. The other members are set to their default values, but the objective term type, which is set to USER_PERFORMANCE_TERM. </p>

</div>
</div>
<a class="anchor" id="a180470a88d21c1c03260797605738668"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td>
          <td class="paramname"><em>new_neural_network_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neural network constructor. It creates a performance functional object associated to a neural network object. The rest of pointers are initialized to NULL. It also initializes all the rest of class members to their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_neural_network_pointer</td><td>Pointer to a neural network object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f5c181e4c5fc96d9f4eeaf29c332d2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td>
          <td class="paramname"><em>new_neural_network_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *&#160;</td>
          <td class="paramname"><em>new_data_set_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neural network and data set constructor. It creates a performance functional object associated to a neural network and a data set objects. The rest of pointers are initialized to NULL. It also initializes all the rest of class members to their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_neural_network_pointer</td><td>Pointer to a neural network object. </td></tr>
    <tr><td class="paramname">new_data_set_pointer</td><td>Pointer to a data set object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae778b47af08c04854df45c0c51a8b989"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td>
          <td class="paramname"><em>new_neural_network_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *&#160;</td>
          <td class="paramname"><em>new_mathematical_model_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neural network and mathematical model constructor. It creates a performance functional object associated to a neural network and a mathematical model objects. The rest of pointers are initialized to NULL. It also initializes all the rest of class members to their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_neural_network_pointer</td><td>Pointer to a neural network object. </td></tr>
    <tr><td class="paramname">new_mathematical_model_pointer</td><td>Pointer to a mathematical model object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef875d39dc1d695e579cabaebfd80840"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td>
          <td class="paramname"><em>new_neural_network_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *&#160;</td>
          <td class="paramname"><em>new_mathematical_model_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *&#160;</td>
          <td class="paramname"><em>new_data_set_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Neural network, mathematical model and data set constructor. It creates a performance functional object associated to a neural network, a mathematical model and a data set objects. The rest of pointers are initialized to NULL. It also initializes all the rest of class members to their default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_neural_network_pointer</td><td>Pointer to a neural network object. </td></tr>
    <tr><td class="paramname">new_mathematical_model_pointer</td><td>Pointer to a mathematical model object. </td></tr>
    <tr><td class="paramname">new_data_set_pointer</td><td>Pointer to a data set object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51b1b6785b2d04dedc96c2d831f3c6ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>File constructor. It creates a performance functional object by loading its members from an XML-type file. Please be careful with the format of that file, which is specified in the OpenNN manual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of performance functional file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa06d3ac07810692f7c962f5bb9604c73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLDocument &amp;&#160;</td>
          <td class="paramname"><em>performance_functional_document</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>XML constructor. It creates a performance functional object by loading its members from an XML document-&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">performance_functional_document</td><td>Pointer to a TinyXML document containing the performance functional data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a240555820e883f37ee9344d0a09052b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_performance_functional.html">PerformanceFunctional</a> &amp;&#160;</td>
          <td class="paramname"><em>other_performance_functional</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. It creates a copy of an existing performance functional object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_performance_functional</td><td>Performance functional object to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000070">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4843ba1fe81a786de21e395c3736a320"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenNN::PerformanceFunctional::~PerformanceFunctional </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. It deletes the objective, regularization and constraints terms. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a24d4b72fc9b02535a29b8283a53dc9b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_constraints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constraints evaluation, according to the respective constraints type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="a661fa98f3f3a3419150d864c80542844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constraints evaluation, according to the respective constraints type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="ac96a36f45aa32fa368a2df71447bef2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_gradient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the constraints, according to the objective type. That gradient is the vector of partial derivatives of the constraints with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="adfc2eba35c0dab870ef4d66e1a6b71cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the constraints, according to the objective type. That gradient is the vector of partial derivatives of the constraints with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="a2b2499cd488e3c92bba49e9dacb66406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_Hessian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the constraints, according to the constraints type. That Hessian is the matrix of second partial derivatives of the constraints with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>

</div>
</div>
<a class="anchor" id="a16e4895dfd91269bc89b5cbb86cf3fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the constraints, according to the constraints type. That Hessian is the matrix of second partial derivatives of the constraints with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a42efac3b8b04a72d6acfd83b558c8145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_terms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000072">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1e35818ffbd6ea8f76cd85bb40129820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_constraints_terms_Jacobian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Jacobian of the constraints terms function, according to the constraints type used in the performance functional expression. Note that this function is only defined when the objective can be expressed as a sum of squared terms. The Jacobian elements are the partial derivatives of a single term with respect to a single parameter. The number of rows in the Jacobian matrix are the number of parameters, and the number of columns the number of terms composing the constraints. </p>

</div>
</div>
<a class="anchor" id="a39cf6b0b32806342b973db17d1e552e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_first_order_Taylor_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Taylor approximation of the performance function at some point near the parameters. The order of the approximation here is one, i.e., both the performance value and the performance gradient are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>Approximation point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0176ba03640588382f2acc57e2d04cf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_generalization_performance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the generalization performance, as the sum of the objective and the regularization terms. </p>

</div>
</div>
<a class="anchor" id="abdc08cefd4ebfbe2202338cd9204b5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the performance gradient for a given vector of parameters. It does not set that vector of parameters to the neural network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a> of parameters for the neural network associated to the performance functional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace7fa47593e4c7c23092d2c25469bec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_Hessian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default objective function Hessian matrix, which is computed as the sum of the objective, regularization and constraints Hessians. </p>

</div>
</div>
<a class="anchor" id="a98113c902a89ab481e6f5cd562e77556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns which would be the objective function Hessian of a neural network for an hypothetical vector of parameters. It does not set that vector of parameters to the neural network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a> of potential parameters for the neural network associated to this performance functional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06870da51e497f42806dc3a83a8b27b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_inverse_Hessian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns inverse matrix of the Hessian. It first computes the Hessian matrix and then computes its inverse. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0bb79570d8df54955eebfcf3672f3806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_objective </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the objective evaluation, according to the respective objective type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="a1cb58a9c980b57b144511b53e5539eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_objective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the objective evaluation, according to the respective objective type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="a11435c2d4956df56c592fc7631c908f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_gradient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the objective, according to the objective type. That gradient is the vector of partial derivatives of the objective with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="a5c2a8427b252378e49a8cbb5658472dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the objective, according to the objective type. That gradient is the vector of partial derivatives of the objective with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="aaf49abba36aafaeace9771e69d4a1fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_Hessian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the objective, according to the objective type. That Hessian is the matrix of second partial derivatives of the objective with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>

</div>
</div>
<a class="anchor" id="aa3b848c89cc10fc067e4683e6d4e3b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the objective, according to the objective type. That Hessian is the matrix of second partial derivatives of the objective with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000073">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a38d1c51ad572859d9fa783bbda2e945f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_terms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the evaluation of all the objective terms, according to the respective objective type used in the performance functional expression. Note that this function is only defined when the objective can be expressed as a sum of squared terms. </p>

</div>
</div>
<a class="anchor" id="a4aea45462340f1ca1095467a9f81a717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_objective_terms_Jacobian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Jacobian of the objective terms function, according to the objective type used in the performance functional expression. Note that this function is only defined when the objective can be expressed as a sum of squared terms. The Jacobian elements are the partial derivatives of a single term with respect to a single parameter. The number of rows in the Jacobian matrix are the number of parameters, and the number of columns the number of terms composing the objective. </p>

</div>
</div>
<a class="anchor" id="a4c5e946a6c0271bd8995fb463bf83b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_performance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the evaluation value of the performance functional, as the sum of the objective, regularization and constraints functionals. </p>

</div>
</div>
<a class="anchor" id="aae5896c72e544457f953af44dd760c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_performance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the performance of a neural network for a given vector of parameters. It does not set that vector of parameters to the neural network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a> of parameters for the neural network associated to the performance functional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a002f687eed18332d085f384624026702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_performance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the performance function at some step along some direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>Direction vector. </td></tr>
    <tr><td class="paramname">rate</td><td>Step value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a948b979f2c1ba7eabf23a7002fd97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_performance_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the derivative of the performance function at some step along some direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>Direction vector. </td></tr>
    <tr><td class="paramname">rate</td><td>Step value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1459980ed63ecfe0b419146031a9c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_performance_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the second derivative of the performance function at some step along some direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>Direction vector. </td></tr>
    <tr><td class="paramname">rate</td><td>Step value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17230372c9f0ee39c21e7c77662eb678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_regularization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the regularization evaluation, according to the respective regularization type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="aff8f4b0c704b73b811eb279c0585a078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_regularization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the regularization evaluation, according to the respective regularization type used in the performance functional expression. </p>

</div>
</div>
<a class="anchor" id="a446879d58a1c823c60e46df1f8f20dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_gradient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the regularization, according to the regularization type. That gradient is the vector of partial derivatives of the regularization with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="ab16d6e10a5ebdbad70c1cc342724c20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the gradient of the regularization, according to the regularization type. That gradient is the vector of partial derivatives of the regularization with respect to the parameters. The size is thus the number of parameters. </p>

</div>
</div>
<a class="anchor" id="ae59ab3a1efd3c691cd8b97a071065081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_Hessian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the regularization, according to the regularization type. That Hessian is the matrix of second partial derivatives of the regularization with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>

</div>
</div>
<a class="anchor" id="a21c90e518afd511e99b128c9d45cf4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Hessian of the regularization, according to the regularization type. That Hessian is the matrix of second partial derivatives of the regularization with respect to the parameters. That matrix is symmetric, with size the number of parameters. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000074">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0e83b2738d9dea8f1998f21df6b962f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_terms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000071">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a63c1362c60440cf388dd95a997622afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_regularization_terms_Jacobian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Jacobian of the regularization terms function, according to the regularization type used in the performance functional expression. Note that this function is only defined when the objective can be expressed as a sum of squared terms. The Jacobian elements are the partial derivatives of a single term with respect to a single parameter. The number of rows in the Jacobian matrix are the number of parameters, and the number of columns the number of terms composing the regularization. </p>

</div>
</div>
<a class="anchor" id="a7385b1b6a129f8357758c4757bbec08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_second_order_Taylor_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Taylor approximation of the performance function at some point near the parameters. The order of the approximation here is two, i.e., the performance value, the performance gradient and the performance Hessian are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>Approximation point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd3260d73f437da8cae5d1937b388452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_terms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates the objective, regularization and constraints terms functions, and returns the total performance terms as the assembly of that three vectors. </p>

</div>
</div>
<a class="anchor" id="a32af53af6abcb22c5978de16159955ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_matrix.html">Matrix</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_terms_Jacobian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a18e518203cce32fb68e5395242253e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; OpenNN::PerformanceFunctional::calculate_vector_dot_Hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the default product of some vector with the objective function Hessian matrix, which is computed using numerical differentiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="class_open_n_n_1_1_vector.html">Vector</a> in the dot product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000078">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a157523e586f178deaa674a3527c74068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OpenNN::PerformanceFunctional::calculate_zero_order_Taylor_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_vector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Taylor approximation of the performance function at some point near the parameters. The order of the approximation here is zero, i.e., only the performance value is used. </p>

</div>
</div>
<a class="anchor" id="a0a08e75fe5f7ed2dc57d250e15a22d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::check_performance_terms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Throws an exception if the performance functional has not got any objective, regularization or constraints terms. </p>

</div>
</div>
<a class="anchor" id="ade324d9351e942dfd121ac99ec547ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::destruct_constraints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method deletes the constraints term object. It also sets the constraints term type to NONE and the corresponding flag to false. </p>

</div>
</div>
<a class="anchor" id="a298db532ce7f97a4efaa6fd423277a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::destruct_objective </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method deletes the objective term object. It also sets the objective term type to NONE and the corresponding flag to false. </p>

</div>
</div>
<a class="anchor" id="a3ca15c610b958c07de111c850d8b8f20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::destruct_regularization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method deletes the regularization term object. It also sets the regularization term type to NONE and the corresponding flag to false. </p>

</div>
</div>
<a class="anchor" id="a9f57d08b92a89c3c66247c571cee296a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::from_XML </td>
          <td>(</td>
          <td class="paramtype">const tinyxml2::XMLDocument &amp;&#160;</td>
          <td class="paramname"><em>document</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the performance functional member data from an XML document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">document</td><td>Pointer to a TinyXML document with the performance functional data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0584c8f2b3724e77f8987b30d964a77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_cross_entropy_error.html">CrossEntropyError</a> * OpenNN::PerformanceFunctional::get_cross_entropy_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the cross entropy error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ae66b5dd6bb62ad5cfee2c611325e9c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool &amp; OpenNN::PerformanceFunctional::get_display </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if messages from this class can be displayed on the screen, or false if messages from this class can't be displayed on the screen. </p>

</div>
</div>
<a class="anchor" id="a80f1f9428c35518bf845baaa8ce21785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> * OpenNN::PerformanceFunctional::get_final_solutions_error_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the final solutions error which is used as constraints. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a0985e9e2448d756c3a09d04e26796910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_final_solutions_error.html">FinalSolutionsError</a> * OpenNN::PerformanceFunctional::get_final_solutions_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the final solutions error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ae2ffd8988f86b990798cdb43d43ff0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> * OpenNN::PerformanceFunctional::get_independent_parameters_error_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the independent parameters error which is used as constraints. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a67383e2ac2e82eb75407256f5def9323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_independent_parameters_error.html">IndependentParametersError</a> * OpenNN::PerformanceFunctional::get_independent_parameters_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the independent parameters error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a3e004f29e554d83a4a200891cdd777c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_inverse_sum_squared_error.html">InverseSumSquaredError</a> * OpenNN::PerformanceFunctional::get_inverse_sum_squared_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the inverse sum squared error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a107e2da8e3f36b905927fb3dff8b1943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_mean_squared_error.html">MeanSquaredError</a> * OpenNN::PerformanceFunctional::get_mean_squared_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the mean squared error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a8d07de4e0ce3441470ec4f3a4e1e5bdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_minkowski_error.html">MinkowskiError</a> * OpenNN::PerformanceFunctional::get_Minkowski_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the Minkowski error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ab0461757be2d42abc68462e154b97cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_neural_parameters_norm.html">NeuralParametersNorm</a> * OpenNN::PerformanceFunctional::get_neural_parameters_norm_regularization_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the neural parameters norm functional which is used as regularization. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac7aca3980e4f52a7f59fd7f557b92417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_normalized_squared_error.html">NormalizedSquaredError</a> * OpenNN::PerformanceFunctional::get_normalized_squared_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the normalized squared error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ae5014c5096cc16c39bd94fd4c7086842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> * OpenNN::PerformanceFunctional::get_outputs_integrals_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the outputs integrals which is used as constraints. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ad9f59ab334da717b8f737cb962e6d3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> * OpenNN::PerformanceFunctional::get_outputs_integrals_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the outputs integrals which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a2282fcca1a9d9bb5b0d15238099cb271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_outputs_integrals.html">OutputsIntegrals</a> * OpenNN::PerformanceFunctional::get_outputs_integrals_regularization_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the outputs integrals functional which is used as regularization. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac29f7f92cdb63928b951f59746ecf5d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_root_mean_squared_error.html">RootMeanSquaredError</a> * OpenNN::PerformanceFunctional::get_root_mean_squared_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the root mean squared error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac020e8e2360fbe84cb5d056bf8cacfd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> * OpenNN::PerformanceFunctional::get_solutions_error_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the solutions error which is used as constraints. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a88d342b93459bc6a4602025185ac9d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_solutions_error.html">SolutionsError</a> * OpenNN::PerformanceFunctional::get_solutions_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the solutions error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="adae77ed9e661528ee8c0dadae2b57643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_sum_squared_error.html">SumSquaredError</a> * OpenNN::PerformanceFunctional::get_sum_squared_error_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the sum squared error which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a1a0c5fd6b7f5be388413b228e58a4812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> * OpenNN::PerformanceFunctional::get_user_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the user constraints functional. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ac7f990bd8bfa1bb92b83a2795a4b9c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> * OpenNN::PerformanceFunctional::get_user_objective_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the user performance term which is used as objective. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a003759a796ebddd2bcdbe956fdb33964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> * OpenNN::PerformanceFunctional::get_user_regularization_pointer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the user regularization functional. If that object does not exists, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a937dfe9f2fd6e94ddd647765e1b013fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenNN::PerformanceFunctional::has_data_set </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this performance functional has a data set associated, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9e4b9d73eea3a9d01a13ed1142bad7ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenNN::PerformanceFunctional::has_generalization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this performance functional has a generalization method defined, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8ce8b800db9415f1b25a9fcb24d9e27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenNN::PerformanceFunctional::has_mathematical_model </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this performance functional has a mathematical model associated, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="aae60cd9ba71d1757d1d935eda0355755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenNN::PerformanceFunctional::has_neural_network </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this performance functional has a neural network associated, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="adefac6dcec92e89c0160d0569b68bf11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a default performance functional XML-type file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of default XML-type performance functional file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa788547aedb28a2a0df57db278490252"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves to a XML-type file a string representation of the performance functional object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Name of XML-type performance functional file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29a93d173f3138f0003ebbdec0abc9de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_constraints_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a3cb05a66b3525ab1a89a5472551447fe">ConstraintsType</a> &amp;&#160;</td>
          <td class="paramname"><em>new_constraints_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new constraints term inside the performance functional of a given performance term type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_constraints_type</td><td>Type of constraints term to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea355d04dc624b97ef7573590204e000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_constraints_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_constraints_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new type for the constraints term from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_constraints_type</td><td>String with the type of constraints term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1202c74530320bc44bb538dc2fd1a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_data_set_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_data_set.html">DataSet</a> *&#160;</td>
          <td class="paramname"><em>new_data_set_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new data set on which it will be measured the performance functional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data_set_pointer</td><td>Pointer to an external data set object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8292e63c87e2ab2f80991eafec1022a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_display </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>new_display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new display value. If it is set to true messages from this class are to be displayed on the screen; if it is set to false messages from this class are not to be displayed on the screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_display</td><td>Display value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5611693b353ccec3cce2309760c96433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_mathematical_model_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_mathematical_model.html">MathematicalModel</a> *&#160;</td>
          <td class="paramname"><em>new_mathematical_model_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new mathematical model on which it will be measured the performance functional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mathematical_model_pointer</td><td>Pointer to an external mathematical model object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cbacd95bd097d39e101eca9658f001c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_neural_network_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_neural_network.html">NeuralNetwork</a> *&#160;</td>
          <td class="paramname"><em>new_neural_network_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a pointer to a multilayer perceptron object which is to be associated to the performance functional. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_neural_network_pointer</td><td>Pointer to a neural network object to be associated to the performance functional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16756324648a453631b730af6cfb6791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_objective_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_performance_functional.html#ac700d3aab8c7b2b7f20a56d4addbb8c7">ObjectiveType</a> &amp;&#160;</td>
          <td class="paramname"><em>new_objective_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new objective term inside the performance functional of a given performance term type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_objective_type</td><td>Type of objective term to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e4c933a0fe5e962bf1a96551560eea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_objective_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_objective_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new type for the objective term from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_objective_type</td><td>String with the type of objective term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb4220578a93f57a260e19d97ffe2271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_regularization_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_n_n_1_1_performance_functional.html#a8f4e9613ff3dd4fc43884b1249b66893">RegularizationType</a> &amp;&#160;</td>
          <td class="paramname"><em>new_regularization_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new regularization term inside the performance functional of a given performance term type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_regularization_type</td><td>Type of regularization term to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5a71b62ea2ab5acb8d3dbc52a755b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_regularization_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_regularization_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new type for the regularization term from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_regularization_type</td><td>String with the type of regularization term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d74d21f2b0357ce42c2ddd97fc39563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_user_constraints_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td>
          <td class="paramname"><em>new_user_constraints_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the constraints term to be a specialized one provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_user_constraints_pointer</td><td>Pointer to a performance term object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ab857bd0c85f358bdb2a7b57b56f33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_user_objective_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td>
          <td class="paramname"><em>new_user_objective_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the objective term to be a specialized one provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_user_objective_pointer</td><td>Pointer to a performance term object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d0eae3cb0aa02d3324c5004099ee1a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenNN::PerformanceFunctional::set_user_regularization_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_open_n_n_1_1_performance_term.html">PerformanceTerm</a> *&#160;</td>
          <td class="paramname"><em>new_user_regularization_pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the regularization term to be a specialized one provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_user_regularization_pointer</td><td>Pointer to a performance term object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adade7042ad9678036715ae93cee6f346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLDocument * OpenNN::PerformanceFunctional::to_XML </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serializes a default performance functional object into a XML document of the TinyXML library. See the OpenNN manual for more information about the format of this element. </p>

</div>
</div>
<a class="anchor" id="a4e6c610158bf2e4bcce7b3e7d33fbaf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OpenNN::PerformanceFunctional::write_information </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns any useful information about the objective function during training. By default it is an empty string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/neural-designer/trunk/source/opennn/source/<a class="el" href="performance__functional_8h_source.html">performance_functional.h</a></li>
<li>C:/neural-designer/trunk/source/opennn/source/performance_functional.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 31 2013 12:16:32 for OpenNN by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
